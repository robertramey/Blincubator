<div class="section" title="Use Concepts and Concept Checking Classes"><div class="titlepage"><div><div><h2 class="title"><a name="idm521639678400"></a>Use Concepts and Concept Checking Classes</h2></div></div><hr></div><p>Use "Concepts" to constain template parameters. This will make your
  library </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>easier to use.</p></li><li class="listitem"><p>easier to learn to use.</p></li><li class="listitem"><p>harder to misuse.</p></li><li class="listitem"><p>more logically coherent.</p></li><li class="listitem"><p>faster to develop.</p></li><li class="listitem"><p>easier and faster to write correct documentation.</p></li></ul></div><div class="section" title="What is a Concept?"><div class="titlepage"><div><div><h3 class="title"><a name="idm521639672208"></a>What is a Concept?</h3></div></div></div><p>For our purposes, we will define "C++ concept" as:</p><p>A C++ Template will have one or more type arguments. The template
    may require that each argument fullfill more or more requirements in order
    for the template to compile without error. These requirements are called
    <span class="emphasis"><em>Concepts</em></span>. In this context, the word concept is
    equivalent to <span class="emphasis"><em>type requirements</em></span> or <span class="emphasis"><em>type
    contraints</em></span>.</p><p>So, for our purposes, the word <span class="emphasis"><em>concepts</em></span> can be
    substituted with <span class="emphasis"><em>type requirements</em></span> or <span class="emphasis"><em>type
    constraints</em></span> without losing meaning. In fact, the meaning word
    <span class="emphasis"><em>concept</em></span> in this context is one of the reasons that
    the subject has been so confusing. Another reason is that it is really
    only necessary to understand <span class="emphasis"><em>concepts</em></span> when writting a
    templated library. Since very few programmers actually write such code,
    very few people actually use this idea and hence are unfamilar with
    it.</p></div><div class="section" title="Concept Checking for Function Templates"><div class="titlepage"><div><div><h3 class="title"><a name="idm521639666640"></a>Concept Checking for Function Templates</h3></div></div></div><p>Our discussion below is largely based on and example from the
    documentation of <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
    Concept Checking Library</a> As an illustration consider the standard
    C library function qsort. The prototype for this function is</p><pre><code>void qsort(
    void *base, 
    size_t nitems, 
    size_t size, 
    int (*compar)(const void *, const void*)
);</code></pre><p>The prototype lists the specific types of the function arguments. In
    other words, the function arguments are <span class="emphasis"><em>constrained</em></span>
    to specific types. Any attempt to compile a call of this function with
    arguments which don't fit this <span class="emphasis"><em>type signature</em></span> will
    result in a compile time error message. This generally works very well and
    is helpful to the user.</p><p>But for a general use library function this declaration has some
    problems. It's defined in terms of void * which require passing data
    without the type information. Then we need to add a "size" parameter. Then
    we need to start type casting the arguments. All this introduces it's own
    set off possibilities for errors which are a pain to track down. This is
    one of the main motivations for the invention of templates.</p><p>This function is defined in terms of any type T to permit it to be
    instantiated for any type.</p><pre><code>template&lt;typename T&gt;
void bubble_sort(T begin, T end);</code></pre><p>That is, we're saying that
    bubble_sort can be invoked with ANY type of arguments. The compiler won't
    detect any error where the function is invoked regardless of which
    arguments we pass to the function! So the following will compile without
    errors:</p><pre><code>#include &lt;vector&gt;
#include &lt;complex&gt;

template&lt;typename T&gt;
void bubble_sort(T begin, T end);

void main(){
    std::vector&lt;std::complex&lt;float&gt; &gt; v;
    bubble_sort(v.begin(), v.end());
}</code></pre><p>Hmmm, surely we can't pass any type to bubble sort. Indeed, when we
    include the implementation:</p><pre><code>#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;utility&gt; // swap

template&lt;typename T&gt;
void bubble_sort(T begin, T end){
    for(T i = begin; i &lt; end; ++i)
        for(T j = i + 1; j &lt; end; ++j)
            if(*j &lt; *i)               // error!
                std::swap(*i, *j);
}

void main(){
    std::vector&lt;std::complex&lt;float&gt; &gt; v;
    bubble_sort(v.begin(), v.end());
}
</code></pre><p>We get an error message on the line including the comparison.
    Looking the implementation, considering that in this case T is defined as
    complex&lt;float&gt;, and recalling that complex is not a type which
    supports comparison we see the source of our error. It is obvious when we
    trace into to the implementation of the algorithm. But doing so can
    consume a huge amount of time when one must trace through several layers
    of templated code. One of the main reasons for using a library is to hide
    the implementation of some possible complicated procedure behind a simple
    declaration of what the function does. Expecting a user to delve deep into
    the implementation of the procedure defeats the reason for using the
    library in the first place!</p><p>So we need some way to add information about what types are
    permeated (type requirements or concepts) and a mechanism to automatically
    trap instances where these requirements are not satisfied. As I write
    this, I recommend usage of the <a class="ulink" href="???" target="_top">Boost Concept Checking
    Library</a> for this purpose. Here is how to use it for our example
    function.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Documentation</th><th align="center">Code</th></tr></thead><tbody><tr><td><pre><code>template&lt;typename T&gt;
void bubble_sort(T begin, T end)

Type T must be an instance of a Forward
Iterator type.

For variables t1 and t2 of type T:

*t1 &lt; *t2 must be valid and return value
convertible to bool

swap(*t1, *t2) must be valid.
</code></pre></td><td><pre><code>#include "boost/concept/requires.hpp"
#include "boost/concept_check.hpp"
#include &lt;iterator&gt; // iterator_traits

template &lt;typename T&gt;
BOOST_CONCEPT_REQUIRES(
  ((boost::ForwardAccessIterator&lt;T&gt;))
  ((boost::LessThanComparable&lt;
     typename std::iterator_traits&lt;T&gt;::value_type
   &gt;))
  ((boost::Swappable&lt;
     typename std::iterator_traits&lt;T&gt;::value_type
  )),
  (void)
)
bubble_sort(T begin, T end);
</code></pre></td></tr></tbody></table></div><p>Note that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The macro BOOST_CONCEPT_REQUIRES takes two arguments: a list
          of requirements, and the return type of the function. In particular,
          note that each requirement is placed in it's own set of parenthesis
          and that requirements are NOT separated by commas. This C++
          unfriendly syntax is a necessary artifact of the way that the macro
          is implemented.</p></li><li class="listitem"><p>There is a one to one correspondence between the clauses in
          the documentation for the function and the lines in the code which
          implement the concept checking.</p></li><li class="listitem"><p>Our example includes type requirements (ForwardAccessIterator,
          LessThanComparable and Swappable) which are already defined in the
          C++ Standard Library. Since the <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
          Concept Checking Library</a> already includes the code for
          checking these requirements, we didn't have to write any code
          ourselves. All we had to do was to indicate which of the standard
          defined requirements should be checked. As it turns out this is
          quite common and many times we don't need to create any new type
          requirements</p></li></ul></div><p>Assuming we've put the code including the type requirements in a
    header named <code class="code">bubble_sort.hpp</code> we can now write a small program
    like this:</p><pre><code>#include &lt;list&gt;
#include &lt;complex&gt;

#include "bubble_sort.hpp"

void main(){
    std::list&lt;std::complex&lt;float&gt; &gt; l;
    bubble_sort(l.begin(), l.end());
}
</code></pre><p>Attempting to compile this program will result in an error listing
    which refers to the source line were
    <code class="code">boost::LessThanComparable</code> is instantiated with a type
    <code class="code">std::complex</code>. Hopefully, this should remind the user to the
    fact that the &lt; operator cannot be applied to the complex data type.
    Note that the user is not required to trace through the implementation of
    bubble sort to discover this fact. In fact, the bubble sort implementation
    is not even required to be present for the error to be detected and
    flagged with a compile time error. This will save your users hours of time
    and frustration and make it more likely that your library is
    successful.</p></div><div class="section" title="Creating Concept Checking Classes"><div class="titlepage"><div><div><h3 class="title"><a name="idm521639641264"></a>Creating Concept Checking Classes</h3></div></div></div><p>The meticulous reader who is compiling the above code examples as he
    reads will have discovered that one thing is not true. The concept
    checking class Swappable is not currently defined in the Boost Concept
    Checking Library. The following is based on <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/creating_concepts.htm" target="_top">Creating
    Concept Checking Classes</a> From the documentation for <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
    Concept Checking Library</a> . The following code defines
    Swappable.</p><pre><code>#include "boost/concept/usage.hpp"
#include "boost/concept/assert.hpp"

template &lt;class T&gt;
struct Swappable {
private:
    T t1, t2; // must be data members
public:
    BOOST_CONCEPT_ASSERT((boost::Assignable&lt;T&gt;));
    BOOST_CONCEPT_USAGE(Swappable)
    {
        swap(t1, t2);
    }
};
</code></pre><p>BOOST_CONCEPT_ASSERT can be used just about anywhere to verify that
    a given type fulfills the type requirements for any defined concept. Here
    it's use to register the fact that any <span class="emphasis"><em>Swappable</em></span> type
    must be <span class="emphasis"><em>Assignable</em></span> as well. That is,
    <span class="emphasis"><em>Swappable</em></span> is a refinement of
    <span class="emphasis"><em>Assignable</em></span>. Given that we've chosen to use
    BOOST_CONCEPT_REQUIRES for function template arguments, the most common
    usage BOOST_CONCEPT_ASSERT would be in class templates.</p></div><div class="section" title="Future Compatibility"><div class="titlepage"><div><div><h3 class="title"><a name="idm521639635104"></a>Future Compatibility</h3></div></div></div><p>Inclusion of <span class="emphasis"><em>concepts</em></span> in C++ has generated a
    huge amount of discussion, activity, experiments, and effort over the last
    decade. Googling "C++ Concepts" will result in many, many hits. <a class="ulink" href="http://www.osl.iu.edu/publications/prints/2013/lvoufo13:_concepts_terminology.pdf" target="_top">This
    paper</a> is one of those and gives a summary of the current state of
    the discussion. The latest effort, <a class="ulink" href="https://docs.google.com/a/isocpp.org/viewer?a=v&amp;pid=forums&amp;srcid=MDIyMDc3NjUwMTczOTM0Mjk3NjABMDI2MzM3MjkxNDM4NDQ5MzE4NDcBLWVsS1Y4dFhtdDhKATQBaXNvY3BwLm9yZwF2Mg" target="_top">Concepts
    Lite</a>, seems to be well received and perhaps destined for approval.
    Still, inclusion in the language and support by compilers is still years
    way. <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
    Concept Checking Library</a> on the other hand, can be used today. The
    following table contrasts <a class="ulink" href="???" target="_top">Boost Concept <a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
    Concept Checking Library</a>Checking Library</a> with <a class="ulink" href="https://docs.google.com/a/isocpp.org/viewer?a=v&amp;pid=forums&amp;srcid=MDIyMDc3NjUwMTczOTM0Mjk3NjABMDI2MzM3MjkxNDM4NDQ5MzE4NDcBLWVsS1Y4dFhtdDhKATQBaXNvY3BwLm9yZwF2Mg" target="_top">Concepts
    Lite</a>:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Boost Concept Checking</th><th align="center">Concepts Lite</th></tr></thead><tbody><tr><td><pre><code>#include "boost/concept/requires.hpp"
#include "boost/concept_check.hpp"
#include &lt;iterator&gt; // iterator_traits

template &lt;typename T&gt;
BOOST_CONCEPT_REQUIRES(
  ((boost::ForwardAccessIterator&lt;T&gt;))
  ((boost::LessThanComparable&lt;
     typename std::iterator_traits&lt;T&gt;::value_type
   &gt;))
  ((boost::Swappable&lt;
     typename std::iterator_traits&lt;T&gt;::value_type
  )),
  (void)
)
bubble_sort(T begin, T end);
</code></pre></td><td><pre><code>template&lt;typename T&gt;
requires 
    ForwardAccessIterator&lt;T&gt;() &amp;&amp;
    LessThanComparable&lt;
        typename std::iterator_traits&lt;T&gt;::value_type
    &gt;() &amp;&amp;
    Swappable&lt;
        typename std::iterator_traits&lt;T&gt;::value_type
    &gt;()
void bubble_sort(T begin, T end);
</code></pre></td></tr><tr><td><pre><code>BOOST_CONCEPT_ASSERT(
    boost::ForwardAccessIterator&lt;T&gt;
)</code></pre></td><td><pre><code>static_assert(std::ForwardAccessIterator&lt;T&gt;())</code></pre></td></tr><tr><td><pre><code>BOOST_CONCEPT_USAGE</code></pre></td><td><pre><code>Unclear on how to specify this at this time</code></pre></td></tr></tbody></table></div><p>It turns out that there is almost a one to one relationship between
    lines of code used to specify concepts in between the two systems. So if
    one uses <a class="ulink" href="???" target="_top">Boost Concept Checking Library</a>. So
    transition to any future standard system when and if that occurs should be
    almost trivial. Also note that users code will not be effected in any way
    since any required changes are confined to the library code modules</p><p>.</p></div><div class="section" title="References"><div class="titlepage"><div><div><h3 class="title"><a name="idm521639616976"></a>References</h3></div></div></div><p>More good information regarding practical aspects of C++ concepts
    and be found by checking the following links</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="http://www.boost.org/doc/libs/1_54_0/libs/concept_check/concept_check.htm" target="_top">Boost
          Concept Checking Library</a></p></li><li class="listitem"><p><a class="ulink" href="http://cpp-next.com/archive/2011/12/a-breakthrough-for-concepts/" target="_top">A
          Breakthrough for Concepts</a></p></li><li class="listitem"><p><a class="ulink" href="http://www.drdobbs.com/windows/checking-concept-without-concepts-in-c/227500449" target="_top">Checking
          Concept Without Concepts in C++</a></p></li><li class="listitem"><p><a class="ulink" href="https://docs.google.com/a/isocpp.org/viewer?a=v&amp;pid=forums&amp;srcid=MDIyMDc3NjUwMTczOTM0Mjk3NjABMDI2MzM3MjkxNDM4NDQ5MzE4NDcBLWVsS1Y4dFhtdDhKATQBaXNvY3BwLm9yZwF2Mg" target="_top">Concepts
          Lite</a></p></li></ul></div><p></p></div></div>
