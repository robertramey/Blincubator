<div class="section" title="Advice"><div class="titlepage"><div><div><h2 class="title"><a name="advice"></a>Advice</h2></div></div><hr></div><p>Here is my personal advice on how to create a successful library for
  Boost or otherwise. I don't lay claim be the originator of any of these.
  They are derived from many different source of software development ideas
  and methodologies. Many of these sources contain overlapping ideas with
  different terminology. </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/Agile_software_development" target="_top">Agile
        Development</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Incremental development</p></li><li class="listitem"><p>continual testing</p></li></ul></div></li><li class="listitem"><p><a class="ulink" href="http://en.wikipedia.org/wiki/Literate_programming" target="_top">Literate
        Programming</a> - consideration of progam and documentation as
        "one thing".</p></li><li class="listitem"><p>Program development though <a class="ulink" href="http://en.wikipedia.org/wiki/Program_derivation" target="_top">Progam
        Derivation</a> - correct program construction through composition
        of demonstrably correct components.</p></li></ul></div><div class="section" title="Write Code, Concepts, Tests and Documentation Concurrently"><div class="titlepage"><div><div><h3 class="title"><a name="id371807"></a>Write Code, Concepts, Tests and Documentation Concurrently</h3></div></div></div><p>This is what we usually do to make a library or other body of
    code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>write all the code</p></li><li class="listitem"><p>write some tests</p></li><li class="listitem"><p>change all the code and tests until the tests to pass on our
        platform</p></li><li class="listitem"><p>start writing documentation and examples</p></li><li class="listitem"><p>upload it and ask people to try it out</p></li></ul></div><p>This approach has a couple of problems.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Coding is fun, while the ancillary tasks can be very boring,
        tedious and frustrating. So leaving these other tasks as an
        afterthought results in poor and/or incomplete documentation, testing,
        and concept definition.</p></li><li class="listitem"><p>Conceptual errors are often discovered when writing
        documentation, tests and concepts. Discovery of these errors usually
        results in changed to the code which ripple through the whole library
        and create a lot of work.</p></li><li class="listitem"><p>Poor/Incomplete documentation/testing/concepts mean that fewer
        conceptual errors are discovered before code is made available to
        users.</p></li><li class="listitem"><p>Users will be shipped code which is weak on documentation,
        tests, and examples and has conceptual errors. Often the library
        writer doesn't do this intentionally, it's just an effect of the way
        the code has been developed. Users will discover these problems,
        reject the library and move on. If the library writer get's any
        feedback it is likely to be of limited usefulness.</p></li><li class="listitem"><p>So reworking code and documentation after everything is "done"
        results in a huge amount of extra work - if the work every get's
        done.</p></li></ul></div><p>The basic problem is that the ancillary tasks create a lot of useful
    information and this needs to be cycled back into the library code before
    anything is shipped. Cycling this information back sooner saves wasted
    time.</p><p>Here is what I recommend instead:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>write a small group of classes. functions, or templates.</p></li><li class="listitem"><p>use concepts - what are concepts?</p></li><li class="listitem"><p>write documentation for this group</p></li><li class="listitem"><p>write and newly required concept checking classes</p></li><li class="listitem"><p>write a program to test this code</p></li><li class="listitem"><p>Repeat above for the next group.</p></li><li class="listitem"><p>When there is enough to be truely useful to someone, upload the
        package as ask people to test it. The package may not have all the
        features planned for it, but it should have enough functionality to be
        useful.</p></li><li class="listitem"><p>Monitor feedback.</p></li><li class="listitem"><p>add features and make adjustments and repeat cycle above.</p></li></ul></div><p>In contrast to the first approach.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Coding, testing, documentation, are divided into shorter tasks.
        So the tedium and frustration are much easier to deal with.</p></li><li class="listitem"><p>Information gleaned from documentation, testing, concepts, and
        user feedback is received sooner and saves much rework and back
        tracking.</p></li><li class="listitem"><p>The result is a higher quality library which:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Exhibits "conceptual integrity". That is, code with a
              clearly defined purpose which is explained in an way which makes
              it obvious what the code is meant to do and how to use
              it.</p></li><li class="listitem"><p>Motviates the user to take the code for a "test drive" by
              including the code in his own application. This should that
              convince the user that the library is bug free, useful, and easy
              to use.</p></li><li class="listitem"><p>Results in the user returning positive feedback and
              request for more features.</p></li><li class="listitem"><p>Motivates the library writer and perhaps other users to
              add features to the library.</p></li></ul></div></li></ul></div></div><div class="section" title="Use Concepts and Concept Checking Classes"><div class="titlepage"><div><div><h3 class="title"><a name="id373412"></a>Use Concepts and Concept Checking Classes</h3></div></div></div><p>include concept checks (also known as "parameter constraints") on
    template parameters to check template parameters. These provide compile
    time checks on the arguments used in template instatiation similar to the
    way that C++ type checking provides compile time checks on the arguments
    of function calls.</p><p><a class="ulink" href="http://www.boost.org/doc/libs/1_49_0/libs/concept_check/reference.htm" target="_top">Boost
    Concept Checking Reference</a> contains of list of widely used
    concepts checking classes. It's very easy to use these in your own class
    and function template definitions:</p><div class="programlisting">#include "boost/concept/assert.hpp"

template&lt;class T&gt;
class my_class_template {
    BOOST_CONCEPT_ASSERT((std::EquallyComparable&lt;T&gt;));
};</div><p>This will cause a compilation error whenever one invokes
    <code class="code">my_class_template&lt;T&gt;</code> on any T which is does not support
    the <code class="code">==</code> operator.</p><p>Be prepared to <a class="ulink" href="http://www.boost.org/doc/libs/1_49_0/libs/concept_check/creating_concepts.htm" target="_top">Create
    Concept Checking Classes</a> classes when your library defines new
    concepts.</p></div><div class="section" title="Keep Notes as You Make Changes"><div class="titlepage"><div><div><h3 class="title"><a name="id371348"></a>Keep Notes as You Make Changes</h3></div></div></div><p>Many libraries have a section entitled "Rationale". This section is
    very helpful for anyone who want's to use the library. The problem is that
    if you wait until you're done to write this section, you can't remember
    what the key decisions were and why you made them. That is, you don't
    remember all the dead ends you discarded to get your final finished
    product. If your library gets to review, someone will suggest that it you
    should of done it using method X instead of method Y</p><p>"Easy" way - don't keep notes. Here's what happens.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>At some point in the development, you discover that you want to
        change a design decision. This means you have to use method X instead
        of method Y. Generally this will occur more than once during the
        development.</p></li><li class="listitem"><p>Finally you get everything done, and submit your library for
        review.</p></li><li class="listitem"><p>Now some smart guy will make a good case for using method Y
        instead of method X which you used. Of course you know that since
        you've been down that road. But now you don't remember exactly why
        method Y couldn't be made to work.</p></li><li class="listitem"><p>So you sort of fake it with a glib response which only provokes
        your critic to make an even stronger case. Now everything has
        escalated to the point where you have to go back and make a really
        exahaustive explanation (maybe even involving sample code!). This
        sucks up a huge amount of time.</p></li></ul></div><p>"Hard" way - keep notes on your decisions as you go:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When you discover you want to change a design decision, add an
        explanation to your log.</p></li><li class="listitem"><p>Keeping such notes diminishes the possibility that you
        accidently change a design decision back to one that has previously
        been determined to be a dead end. Don't laugh - this is not hard to
        do!</p></li><li class="listitem"><p>When writing documentation, take these notes, clean them up and
        include them in a section called "Rationale". This makes writing this
        very useful documentation trivial.</p></li><li class="listitem"><p>Users and library reviewers will be able to see your case before
        they make their "suggestions". This short circuits lot's of pointless
        discussions. There will likely still be differences of opinion, but
        all the issues will be visible to all parties at the same time.</p></li></ul></div></div><div class="section" title="Use Other Boost Components"><div class="titlepage"><div><div><h3 class="title"><a name="id373566"></a>Use Other Boost Components</h3></div></div></div><p>If there's already a boost component which performs some function
    you need - use it.</p></div><div class="section" title="Use the Release Branch for Testing"><div class="titlepage"><div><div><h3 class="title"><a name="id373580"></a>Use the Release Branch for Testing</h3></div></div></div><p>If you're making a library which you hope to get accepted into
    Boost, it will very likely depend upon other boost library components. Do
    not test your code against the Boost Trunk. Consider the
    following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You're using Boot Test Library to test your library.</p></li><li class="listitem"><p>The Boost Test author makes a change and tests it on his own
          system.</p></li><li class="listitem"><p>He uploads it to the trunk for testing on all other
          compilers/OS combination which Boost Supports.</p></li><li class="listitem"><p>Over the next few days it turns out that the code is broken on
          some platforms he couldn't test on. So he endeavors to make the code
          fixes required.</p></li><li class="listitem"><p>Meanwhile, you've updated your local copy and you test your
          new library. But now you get a number of subtle problems of unknown
          origin. You have to spend a lot of time tracking down errors which
          are not in your own code at all! This is a huge waste of
          time.</p></li><li class="listitem"><p>Eventually, the Boost Test Library author get's all the tests
          passing and the problem goes away - IF you happen to update your
          local copy from the trunk in the meantime.</p></li><li class="listitem"><p>This scenario supposes that you've only got one Boot Library
          dependency in your code. In reality, due to the nested library
          structure of all software libraries, you'll actually be dependent on
          dozens of other libraries which your are not even aware of.</p></li></ul></div><p>Using the Boost Trunk copy of libraries is a huge waste
    of your time - don't do it!</p></div><div class="section" title="Use a Version Control System"><div class="titlepage"><div><div><h3 class="title"><a name="id373694"></a>Use a Version Control System</h3></div></div></div><p></p></div><div class="section" title="Understand that Writing a Library is Different"><div class="titlepage"><div><div><h3 class="title"><a name="id373703"></a>Understand that Writing a Library is Different</h3></div></div></div><p></p></div></div>
